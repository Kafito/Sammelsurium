#!/bin/bash
# lacl - launch and control later
# a script to start a process as a daemon and provide the opportunity to attach to the console of this program
# open issues / todos
# - Allow for custom configurations for a daemon specific graceful quit command.
#(-)Create Kill command
#(-)Create Cleanup Command

USAGE="Usage: lacl start \$TOKEN command [arg1 arg2 ...] | lacl connect \$TOKEN"

main() {
  WHAT="$1"; shift
  TOKEN="$1"; shift
  
  if [[ -z "$TOKEN" ||  -z "$WHAT" ]]; then
    echo "$USAGE"
    exit
  fi
  
  FIFO_NAME="/dev/shm/$TOKEN.ctl"
  LOG_FILE="/dev/shm/$TOKEN.log"
  
  # evaluate command
  case "$WHAT" in 
    start)
      start $@
    ;;
    connect)
      connect
    ;;
  esac
}

# setup handlers
setup_files() {
  exec {daemonlogfile}>"$LOG_FILE"
  exec {daemon_comm}<>"${FIFO_NAME}"
}

# prepare cleanup
cleanup() {
  exec {daemon_comm}>&-
  rm  -v "$LOG_FILE" "$FIFO_NAME"
}

start() {

  if [ -e "$FIFO_NAME" ]; then
    echo "Error: Token already in use (or not cleaned up correctly)"
    echo "$USAGE"
    exit -1
  fi

  # setup fifo
  mkfifo --mode=0620 "${FIFO_NAME}"
  setup_files

  (
    # echo $FIFO_NAME $LOG_FILE
    COMMAND=$1; shift
    if [ -z "$COMMAND" ]; then
      echo "$USAGE"
    fi
  
    # disable SIGTERM and SIGINT for the daemon process:
    trap "" SIGTERM # avoid kills by systemctl
    trap "" SIGINT # avoid kills when the interactive console is aborted
    
    # start the daemon process
    $COMMAND $@ <&${daemon_comm} >&${daemonlogfile} 2>&${daemonlogfile} &
    
    # Now get the PID of daemon, issue stop, wait for it synchronously within the signal handler and clean up afterwards -- 
    PID=$!
    trap "echo stop >${FIFO_NAME}; wait $PID" SIGTERM #TODO: make stop command configurable

    trap "" SIGKILL # can't ignore SIGKILL, but this prevents an unecessary message on the console "lacl: line XX: $PID Killed [...]"

    # wait and clean up afterwards
    trap cleanup EXIT

    wait $PID 
  ) & 
}

connect() {
  # assert fifo exists

  if ! [ -p "$FIFO_NAME" ]; then
    echo "Error: Pipe not found!"
    echo "You need to start a command for the given token first."
    echo "$USAGE"
    exit -1
  fi

  # setup_files -- should not be used.

  tail -f "$LOG_FILE" &
  local TAILPID=$!

  trap "kill $TAILPID" EXIT 
  while IFS= read -r -s -d "$(echo -ne '\0004')" -n 1 char; do
    if [[ ! -p "$FIFO_NAME" ]]; then echo "connection lost"; break; fi
    echo -ne "$char" >"${FIFO_NAME}"
  done
}

main $@

#function connect {
#tail -f "$LOG_FILE" &
#start the interactive shell emulation
#TODO: issue tail-f background, if possible, to create some kind of a interative shell
#while read line; do
#  if [ -p "${FIFO_NAME}" ]; then
#    echo "cmd: $line"
#  else
#    echo "named pipe does not exist anymore, aborting server frontend" >&2
#    break
#  fi
#done >"${FIFO_NAME}"
#}


#kafi@v22014082319219779 startattachable]$ while true; do IFS= read -r -n 1 line; echo "$line"; done <&${testfifo} &
#[1] 1692
#[kafi@v22014082319219779 startattachable]$ while IFS= read -r -n1 char; do echo -n "$char" > test; done

